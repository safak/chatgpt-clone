"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ClerkExpressRequireAuth: () => ClerkExpressRequireAuth,
  ClerkExpressWithAuth: () => ClerkExpressWithAuth,
  clerkClient: () => clerkClient,
  createClerkClient: () => createClerkClient,
  createClerkExpressRequireAuth: () => createClerkExpressRequireAuth,
  createClerkExpressWithAuth: () => createClerkExpressWithAuth,
  requireAuth: () => requireAuth,
  withAuth: () => withAuth
});
module.exports = __toCommonJS(src_exports);

// src/clerkClient.ts
var import_backend = require("@clerk/backend");

// src/authenticateRequest.ts
var import_internal = require("@clerk/backend/internal");
var import_handleValueOrFn = require("@clerk/shared/handleValueOrFn");
var import_keys = require("@clerk/shared/keys");
var import_proxy = require("@clerk/shared/proxy");

// src/utils.ts
var import_underscore = require("@clerk/shared/underscore");
function runMiddleware(req, res, fn) {
  return new Promise((resolve, reject) => {
    void fn(req, res, (result) => {
      if (result instanceof Error) {
        return reject(result);
      }
      return resolve(result);
    });
  });
}
var loadClientEnv = () => {
  return {
    publishableKey: process.env.CLERK_PUBLISHABLE_KEY || "",
    clerkJSUrl: process.env.CLERK_JS || "",
    clerkJSVersion: process.env.CLERK_JS_VERSION || ""
  };
};
var loadApiEnv = () => {
  return {
    secretKey: process.env.CLERK_SECRET_KEY || "",
    apiUrl: process.env.CLERK_API_URL || "https://api.clerk.com",
    apiVersion: process.env.CLERK_API_VERSION || "v1",
    domain: process.env.CLERK_DOMAIN || "",
    proxyUrl: process.env.CLERK_PROXY_URL || "",
    signInUrl: process.env.CLERK_SIGN_IN_URL || "",
    isSatellite: (0, import_underscore.isTruthy)(process.env.CLERK_IS_SATELLITE),
    jwtKey: process.env.CLERK_JWT_KEY || "",
    sdkMetadata: {
      name: "@clerk/clerk-sdk-node",
      version: "5.0.48",
      environment: process.env.NODE_ENV
    }
  };
};

// src/authenticateRequest.ts
var authenticateRequest = (opts) => {
  const { clerkClient: clerkClient2, secretKey, publishableKey, req: incomingMessage, options } = opts;
  const { jwtKey, authorizedParties, audience } = options || {};
  const clerkRequest = (0, import_internal.createClerkRequest)(incomingMessageToRequest(incomingMessage));
  const env = { ...loadApiEnv(), ...loadClientEnv() };
  const isSatellite = (0, import_handleValueOrFn.handleValueOrFn)(options?.isSatellite, clerkRequest.clerkUrl, env.isSatellite);
  const domain = (0, import_handleValueOrFn.handleValueOrFn)(options?.domain, clerkRequest.clerkUrl) || env.domain;
  const signInUrl = options?.signInUrl || env.signInUrl;
  const proxyUrl = absoluteProxyUrl(
    (0, import_handleValueOrFn.handleValueOrFn)(options?.proxyUrl, clerkRequest.clerkUrl, env.proxyUrl),
    clerkRequest.clerkUrl.toString()
  );
  if (isSatellite && !proxyUrl && !domain) {
    throw new Error(satelliteAndMissingProxyUrlAndDomain);
  }
  if (isSatellite && !(0, import_proxy.isHttpOrHttps)(signInUrl) && (0, import_keys.isDevelopmentFromSecretKey)(secretKey || "")) {
    throw new Error(satelliteAndMissingSignInUrl);
  }
  return clerkClient2.authenticateRequest(clerkRequest, {
    audience,
    secretKey,
    publishableKey,
    jwtKey,
    authorizedParties,
    proxyUrl,
    isSatellite,
    domain,
    signInUrl
  });
};
var incomingMessageToRequest = (req) => {
  const headers = Object.keys(req.headers).reduce((acc, key) => Object.assign(acc, { [key]: req?.headers[key] }), {});
  const protocol = req.connection?.encrypted ? "https" : "http";
  let dummyOriginReqUrl;
  try {
    dummyOriginReqUrl = new URL(req.url || "", `${protocol}://clerk-dummy`);
  } catch (e) {
    throw new Error(`Invalid request URL: ${req.url}`);
  }
  return new Request(dummyOriginReqUrl, {
    method: req.method,
    headers: new Headers(headers)
  });
};
var setResponseHeaders = (requestState, res) => {
  if (requestState.headers) {
    requestState.headers.forEach((value, key) => res.appendHeader(key, value));
  }
  return setResponseForHandshake(requestState, res);
};
var setResponseForHandshake = (requestState, res) => {
  const hasLocationHeader = requestState.headers.get("location");
  if (hasLocationHeader) {
    res.status(307).end();
    return;
  }
  if (requestState.status === import_internal.AuthStatus.Handshake) {
    return new Error("Clerk: unexpected handshake without redirect");
  }
  return;
};
var absoluteProxyUrl = (relativeOrAbsoluteUrl, baseUrl) => {
  if (!relativeOrAbsoluteUrl || !(0, import_proxy.isValidProxyUrl)(relativeOrAbsoluteUrl) || !(0, import_proxy.isProxyUrlRelative)(relativeOrAbsoluteUrl)) {
    return relativeOrAbsoluteUrl;
  }
  return new URL(relativeOrAbsoluteUrl, baseUrl).toString();
};
var satelliteAndMissingProxyUrlAndDomain = "Missing domain and proxyUrl. A satellite application needs to specify a domain or a proxyUrl";
var satelliteAndMissingSignInUrl = `
Invalid signInUrl. A satellite application requires a signInUrl for development instances.
Check if signInUrl is missing from your configuration or if it is not an absolute URL.`;

// src/clerkExpressRequireAuth.ts
var createClerkExpressRequireAuth = (createOpts) => {
  const { clerkClient: clerkClient2, secretKey = "", publishableKey = "" } = createOpts;
  return (options = {}) => {
    return async (req, res, next) => {
      let requestState;
      try {
        requestState = await authenticateRequest({
          clerkClient: clerkClient2,
          secretKey,
          publishableKey,
          req,
          options
        });
      } catch (e) {
        next(e);
        return;
      }
      const err = setResponseHeaders(requestState, res);
      if (err || res.writableEnded) {
        if (err) {
          next(err);
        }
        return;
      }
      if (requestState.isSignedIn) {
        req.auth = { ...requestState.toAuth(), claims: requestState.toAuth().sessionClaims };
        next();
        return;
      }
      next(new Error("Unauthenticated"));
    };
  };
};

// src/clerkExpressWithAuth.ts
var createClerkExpressWithAuth = (createOpts) => {
  const { clerkClient: clerkClient2, secretKey = "", publishableKey = "" } = createOpts;
  return (options = {}) => {
    return async (req, res, next) => {
      let requestState;
      try {
        requestState = await authenticateRequest({
          clerkClient: clerkClient2,
          secretKey,
          publishableKey,
          req,
          options
        });
      } catch (e) {
        next(e);
        return;
      }
      const err = setResponseHeaders(requestState, res);
      if (err || res.writableEnded) {
        if (err) {
          next(err);
        }
        return;
      }
      req.auth = {
        ...requestState.toAuth(),
        claims: requestState.toAuth()?.sessionClaims
      };
      next();
    };
  };
};

// src/clerkClient.ts
var buildVerifyToken = (params) => {
  return (...args) => (0, import_backend.verifyToken)(args[0], {
    ...params,
    ...args[1]
  });
};
function createClerkClient(options) {
  const clerkClient2 = (0, import_backend.createClerkClient)(options);
  const expressWithAuth = createClerkExpressWithAuth({ ...options, clerkClient: clerkClient2 });
  const expressRequireAuth = createClerkExpressRequireAuth({ ...options, clerkClient: clerkClient2 });
  return Object.assign(clerkClient2, {
    expressWithAuth,
    expressRequireAuth,
    verifyToken: buildVerifyToken(options)
  });
}
var clerkClientSingleton = {};
var clerkClient = new Proxy(clerkClientSingleton, {
  get(_target, property) {
    const hasBeenInitialised = !!clerkClientSingleton.authenticateRequest;
    if (hasBeenInitialised) {
      return clerkClientSingleton[property];
    }
    const env = { ...loadApiEnv(), ...loadClientEnv() };
    if (env.secretKey) {
      clerkClientSingleton = createClerkClient({ ...env, userAgent: `${"@clerk/clerk-sdk-node"}@${"5.0.48"}` });
      return clerkClientSingleton[property];
    }
    const c = createClerkClient({ ...env, userAgent: `${"@clerk/clerk-sdk-node"}@${"5.0.48"}` });
    return c[property];
  },
  set() {
    return false;
  }
});
var ClerkExpressRequireAuth = (...args) => {
  const env = { ...loadApiEnv(), ...loadClientEnv() };
  const fn = createClerkExpressRequireAuth({ clerkClient, ...env });
  return fn(...args);
};
var ClerkExpressWithAuth = (...args) => {
  const env = { ...loadApiEnv(), ...loadClientEnv() };
  const fn = createClerkExpressWithAuth({ clerkClient, ...env });
  return fn(...args);
};

// src/index.ts
__reExport(src_exports, require("@clerk/backend"), module.exports);

// src/requireAuth.ts
function requireAuth(handler, options) {
  return async (req, res) => {
    await runMiddleware(req, res, createClerkExpressRequireAuth({ clerkClient })(options));
    return handler(req, res);
  };
}

// src/withAuth.ts
function withAuth(handler, options) {
  return async (req, res) => {
    await runMiddleware(req, res, createClerkExpressWithAuth({ clerkClient })(options));
    return handler(req, res);
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ClerkExpressRequireAuth,
  ClerkExpressWithAuth,
  clerkClient,
  createClerkClient,
  createClerkExpressRequireAuth,
  createClerkExpressWithAuth,
  requireAuth,
  withAuth,
  ...require("@clerk/backend")
});
//# sourceMappingURL=index.js.map